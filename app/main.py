from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.graph_loader import graph_loader
from app.core_logic import process_query_pipeline
from typing import List, Optional
from pydantic import BaseModel
import uvicorn

app = FastAPI(title="AI Curriculum Tutor (Graph RAG)")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Startup
@app.on_event("startup")
async def startup_event():
    graph_loader.load_graph()
    print("System backend started.")

# Models
class ChatRequest(BaseModel):
    query: str

# Endpoints
@app.get("/health")
def health():
    return {"status": "ok"}

@app.get("/chat")
def chat_endpoint(query: str):
    """
    RAG Chat Endpoint: Text -> SPARQL -> Answer
    """
    result = process_query_pipeline(query)
    # Result contains: {'answer': ..., 'query': ..., 'data': ...}
    
    # Extract Node IDs from SPARQL results if possible
    roadmap = []
    if result.get('data'):
        for item in result['data']:
            # Heuristic: look for URI-like values ending in ID
            for k, v in item.items():
                if isinstance(v, str) and "http" in v:
                    sid = v.split('/')[-1]
                    roadmap.append({"ID": sid})
    
    answer_text = result['answer']
    
    # Add SPARQL Explanation Block
    if result.get('query'):
        escaped_query = result['query'].strip().replace('<', '&lt;')
        explanation = f"""
        <details style='margin-top:10px; border:1px solid #ddd; padding:10px; border-radius:5px;'>
           <summary style='cursor:pointer; font-weight:bold; color:#555;'>üõ†Ô∏è SPARQL Reasoning Logic (Click)</summary>
           <pre style='background:#f4f4f4; padding:5px; font-size:0.8em; overflow-x:auto;'>{escaped_query}</pre>
           <p style='font-size:0.8em; color:#666;'>Generated by Gemini (Text-to-SPARQL)</p>
        </details>
        """
        answer_text += f"<br>{explanation}"

    return {
        "answer": answer_text,
        "roadmap": roadmap
    }

@app.get("/graph")
def get_graph():
    """
    Returns full graph for Cytoscape.
    """
    g = graph_loader.get_graph()
    
    nodes = []
    edges = []
    
    # 1. Nodes
    q_nodes = """
    SELECT ?s ?title ?sem ?type ?domain
    WHERE {
        ?s rdf:type ?type .
        FILTER(?type IN (curr:JBNUSubject, curr:COSSSubject))
        ?s curr:hasTitle ?title .
        OPTIONAL { ?s curr:hasSemester ?sem }
        OPTIONAL { ?s curr:hasDomain ?domain }
    }
    """
    
    # Namespace
    try:
        res = g.query(q_nodes)
        seen_nodes = set()
        
        for row in res:
            sid = str(row.s).split('/')[-1]
            stype = "JBNU" if "JBNU" in str(row.type) else "COSS"
            dom = str(row.domain) if row.domain else "General"
            
            nodes.append({
                "id": sid,
                "label": str(row.title),
                "type": stype,
                "semester": str(row.sem) if row.sem else "Unknown",
                "domain": dom
            })
            seen_nodes.add(sid)
            
        # 2. Edges
        q_edges = """
        SELECT ?s ?o
        WHERE {
            ?s curr:hasPrerequisite ?o .
        }
        """
        
        res_e = g.query(q_edges)
        for row in res_e:
            src = str(row.o).split('/')[-1] 
            tgt = str(row.s).split('/')[-1] 
            
            if src in seen_nodes and tgt in seen_nodes:
                edges.append({"source": src, "target": tgt})
                
    except Exception as e:
        print(f"Graph Query Error: {e}")
            
    return {"nodes": nodes, "edges": edges}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
